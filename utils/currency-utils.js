// Utility functions for Currency Converter Extension

/**
 * Currency data and helper functions
 */

// Comprehensive list of supported currencies
export const CURRENCIES = {
  USD: { name: 'US Dollar', symbol: '$', flag: 'üá∫üá∏' },
  EUR: { name: 'Euro', symbol: '‚Ç¨', flag: 'üá™üá∫' },
  GBP: { name: 'British Pound', symbol: '¬£', flag: 'üá¨üáß' },
  JPY: { name: 'Japanese Yen', symbol: '¬•', flag: 'üáØüáµ' },
  AUD: { name: 'Australian Dollar', symbol: 'A$', flag: 'üá¶üá∫' },
  CAD: { name: 'Canadian Dollar', symbol: 'C$', flag: 'üá®üá¶' },
  CHF: { name: 'Swiss Franc', symbol: 'CHF', flag: 'üá®üá≠' },
  CNY: { name: 'Chinese Yuan', symbol: '¬•', flag: 'üá®üá≥' },
  SEK: { name: 'Swedish Krona', symbol: 'kr', flag: 'üá∏üá™' },
  NZD: { name: 'New Zealand Dollar', symbol: 'NZ$', flag: 'üá≥üáø' },
  MXN: { name: 'Mexican Peso', symbol: '$', flag: 'üá≤üáΩ' },
  SGD: { name: 'Singapore Dollar', symbol: 'S$', flag: 'üá∏üá¨' },
  HKD: { name: 'Hong Kong Dollar', symbol: 'HK$', flag: 'üá≠üá∞' },
  NOK: { name: 'Norwegian Krone', symbol: 'kr', flag: 'üá≥üá¥' },
  TRY: { name: 'Turkish Lira', symbol: '‚Ç∫', flag: 'üáπüá∑' },
  ZAR: { name: 'South African Rand', symbol: 'R', flag: 'üáøüá¶' },
  BRL: { name: 'Brazilian Real', symbol: 'R$', flag: 'üáßüá∑' },
  INR: { name: 'Indian Rupee', symbol: '‚Çπ', flag: 'üáÆüá≥' },
  KRW: { name: 'South Korean Won', symbol: '‚Ç©', flag: 'üá∞üá∑' },
  RUB: { name: 'Russian Ruble', symbol: '‚ÇΩ', flag: 'üá∑üá∫' },
  PLN: { name: 'Polish Zloty', symbol: 'z≈Ç', flag: 'üáµüá±' },
  CZK: { name: 'Czech Koruna', symbol: 'Kƒç', flag: 'üá®üáø' },
  HUF: { name: 'Hungarian Forint', symbol: 'Ft', flag: 'üá≠üá∫' },
  ILS: { name: 'Israeli Shekel', symbol: '‚Ç™', flag: 'üáÆüá±' },
  THB: { name: 'Thai Baht', symbol: '‡∏ø', flag: 'üáπüá≠' },
  PHP: { name: 'Philippine Peso', symbol: '‚Ç±', flag: 'üáµüá≠' },
  MYR: { name: 'Malaysian Ringgit', symbol: 'RM', flag: 'üá≤üáæ' },
  IDR: { name: 'Indonesian Rupiah', symbol: 'Rp', flag: 'üáÆüá©' },
  VND: { name: 'Vietnamese Dong', symbol: '‚Ç´', flag: 'üáªüá≥' },
  // Additional currencies for enhanced support
  DKK: { name: 'Danish Krone', symbol: 'kr', flag: 'üá©üá∞' },
  BGN: { name: 'Bulgarian Lev', symbol: '–ª–≤', flag: 'üáßüá¨' },
  RON: { name: 'Romanian Leu', symbol: 'lei', flag: 'üá∑üá¥' },
  HRK: { name: 'Croatian Kuna', symbol: 'kn', flag: 'üá≠üá∑' },
  UAH: { name: 'Ukrainian Hryvnia', symbol: '‚Ç¥', flag: 'üá∫üá¶' },
  EGP: { name: 'Egyptian Pound', symbol: '¬£', flag: 'üá™üá¨' },
  AED: { name: 'UAE Dirham', symbol: 'ÿØ.ÿ•', flag: 'üá¶üá™' },
  SAR: { name: 'Saudi Riyal', symbol: 'Ô∑º', flag: 'üá∏üá¶' },
  QAR: { name: 'Qatari Riyal', symbol: 'Ô∑º', flag: 'üá∂üá¶' },
  KWD: { name: 'Kuwaiti Dinar', symbol: 'ÿØ.ŸÉ', flag: 'üá∞üáº' },
  BHD: { name: 'Bahraini Dinar', symbol: '.ÿØ.ÿ®', flag: 'üáßüá≠' },
  OMR: { name: 'Omani Rial', symbol: 'Ô∑º', flag: 'üá¥üá≤' },
  JOD: { name: 'Jordanian Dinar', symbol: 'ÿØ.ÿß', flag: 'üáØüá¥' },
  LBP: { name: 'Lebanese Pound', symbol: 'ŸÑ.ŸÑ', flag: 'üá±üáß' }
};

// Popular currencies (for quick access)
export const POPULAR_CURRENCIES = [
  'USD',
  'EUR',
  'GBP',
  'JPY',
  'CAD',
  'AUD',
  'CHF',
  'CNY'
];

/**
 * Format currency amount with proper symbols and locale
 * @param {number} amount - The amount to format
 * @param {string} currencyCode - ISO currency code
 * @param {string} locale - Locale for formatting (default: 'en-US')
 * @returns {string} Formatted currency string
 */
export function formatCurrency(amount, currencyCode, locale = 'en-US') {
  try {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currencyCode,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  } catch {
    // Fallback formatting
    const currency = CURRENCIES[currencyCode];
    const symbol = currency ? currency.symbol : currencyCode;
    return `${symbol}${amount.toFixed(2)}`;
  }
}

/**
 * Parse currency amount from text
 * @param {string} text - Text containing currency amount
 * @returns {object|null} Parsed currency info or null
 */
export function parseCurrencyFromText(text) {
  // Remove extra whitespace
  text = text.trim();

  // Currency patterns (more comprehensive)
  const patterns = [
    // Symbol first: $100, ‚Ç¨50, ¬£75
    /^([‚Ç¨¬£¬•‚Çπ‚ÇΩ¬¢‚Ç©‚Ç¶‚Ç™‚Ç®‚Ç´‚Ç±‚Ç°‚Ç≤‚Ç¥‚Çµ‚Ç∏‚Ç∫‚Çæ‚Çø$])\s*(\d{1,3}(?:,\d{3})*(?:\.\d{1,4})?)$/,

    // Amount first: 100$, 50‚Ç¨, 75¬£
    /^(\d{1,3}(?:,\d{3})*(?:\.\d{1,4})?)\s*([‚Ç¨¬£¬•‚Çπ‚ÇΩ¬¢‚Ç©‚Ç¶‚Ç™‚Ç®‚Ç´‚Ç±‚Ç°‚Ç≤‚Ç¥‚Çµ‚Ç∏‚Ç∫‚Çæ‚Çø$])$/,

    // Code after: 100 USD, 50 EUR
    /^(\d{1,3}(?:,\d{3})*(?:\.\d{1,4})?)\s+([A-Z]{3})$/,

    // Code before: USD 100, EUR 50
    /^([A-Z]{3})\s+(\d{1,3}(?:,\d{3})*(?:\.\d{1,4})?)$/
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      let amount, currency;

      if (pattern.source.startsWith('^([‚Ç¨¬£¬•‚Çπ‚ÇΩ¬¢‚Ç©‚Ç¶‚Ç™‚Ç®‚Ç´‚Ç±‚Ç°‚Ç≤‚Ç¥‚Çµ‚Ç∏‚Ç∫‚Çæ‚Çø$])')) {
        // Symbol first
        currency = symbolToCurrencyCode(match[1]);
        amount = parseFloat(match[2].replace(/,/g, ''));
      } else if (pattern.source.includes('([‚Ç¨¬£¬•‚Çπ‚ÇΩ¬¢‚Ç©‚Ç¶‚Ç™‚Ç®‚Ç´‚Ç±‚Ç°‚Ç≤‚Ç¥‚Çµ‚Ç∏‚Ç∫‚Çæ‚Çø$])$')) {
        // Amount first
        amount = parseFloat(match[1].replace(/,/g, ''));
        currency = symbolToCurrencyCode(match[2]);
      } else if (pattern.source.includes('([A-Z]{3})$')) {
        // Code after
        amount = parseFloat(match[1].replace(/,/g, ''));
        currency = match[2];
      } else {
        // Code before
        currency = match[1];
        amount = parseFloat(match[2].replace(/,/g, ''));
      }

      if (currency && !isNaN(amount) && amount > 0) {
        return {
          amount: amount,
          currency: currency,
          originalText: text
        };
      }
    }
  }

  return null;
}

/**
 * Convert currency symbol to currency code
 * @param {string} symbol - Currency symbol
 * @returns {string} Currency code
 */
export function symbolToCurrencyCode(symbol) {
  const symbolMap = {
    $: 'USD',
    '‚Ç¨': 'EUR',
    '¬£': 'GBP',
    '¬•': 'JPY',
    '‚Çπ': 'INR',
    '‚ÇΩ': 'RUB',
    '¬¢': 'USD',
    '‚Ç©': 'KRW',
    '‚Ç¶': 'NGN',
    '‚Ç™': 'ILS',
    '‚Ç®': 'PKR',
    '‚Ç´': 'VND',
    '‚Ç±': 'PHP',
    '‚Ç°': 'CRC',
    '‚Ç≤': 'PYG',
    '‚Ç¥': 'UAH',
    '‚Çµ': 'GHS',
    '‚Ç∏': 'KZT',
    '‚Ç∫': 'TRY',
    '‚Çæ': 'GEL',
    '‚Çø': 'BTC'
  };

  return symbolMap[symbol] || 'USD';
}

/**
 * Validate currency code
 * @param {string} code - Currency code to validate
 * @returns {boolean} True if valid
 */
export function isValidCurrencyCode(code) {
  return CURRENCIES.hasOwnProperty(code.toUpperCase());
}

/**
 * Get currency display name
 * @param {string} code - Currency code
 * @returns {string} Display name
 */
export function getCurrencyDisplayName(code) {
  const currency = CURRENCIES[code.toUpperCase()];
  return currency ? `${code} - ${currency.name}` : code;
}

/**
 * Debounce function for performance optimization
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} Debounced function
 */
export function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Storage utilities
 */
export const storage = {
  async get(keys) {
    return new Promise(resolve => {
      chrome.storage.sync.get(keys, resolve);
    });
  },

  async set(data) {
    return new Promise(resolve => {
      chrome.storage.sync.set(data, resolve);
    });
  },

  async remove(keys) {
    return new Promise(resolve => {
      chrome.storage.sync.remove(keys, resolve);
    });
  }
};

/**
 * Logger utility
 */
export const logger = {
  log: (message, ...args) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(`[Currency Converter] ${message}`, ...args);
    }
  },

  error: (message, ...args) => {
    console.error(`[Currency Converter] ERROR: ${message}`, ...args);
  },

  warn: (message, ...args) => {
    console.warn(`[Currency Converter] WARNING: ${message}`, ...args);
  }
};

/**
 * Currency pattern testing utilities for Task 2.1
 */
export const TEST_CASES = {
  // Symbol format tests
  symbols: [
    '$430',
    '430$',
    '‚Ç¨500',
    '500‚Ç¨',
    '¬£75',
    '¬•1000',
    'A$50',
    'C$75',
    'HK$100',
    'S$200',
    'NZ$150',
    '‚Çπ2000',
    '‚ÇΩ500',
    '‚Ç©50000',
    '‡∏ø1500',
    'R$300',
    'R150',
    'RM250',
    'z≈Ç100',
    'Kƒç500',
    'Ft1000',
    '$1,234.56',
    '‚Ç¨1.234,56',
    '¬£12,345.67'
  ],

  // Code format tests
  codes: [
    '430 USD',
    '500 EUR',
    '75 GBP',
    '1000 JPY',
    '50 AUD',
    '75 CAD',
    '100 CHF',
    '200 CNY',
    '1,234.56 USD',
    '1.234,56 EUR',
    '12,345 JPY'
  ],

  // Code first format tests
  codesFirst: [
    'USD 430',
    'EUR 500',
    'GBP 75',
    'JPY 1000',
    'AUD 50',
    'CAD 75',
    'CHF 100',
    'CNY 200'
  ],

  // Word format tests
  words: [
    '100 dollars',
    '50 euros',
    '75 pounds',
    '1000 yen',
    '200 yuan',
    '500 pesos',
    '2000 rupees',
    '50000 won',
    '500 rubles',
    '100 francs',
    '250 krona',
    '150 zloty'
  ],

  // Word first format tests
  wordsFirst: [
    'dollars 100',
    'euros 50',
    'pounds 75',
    'yen 1000',
    'yuan 200',
    'pesos 500',
    'rupees 2000',
    'won 50000'
  ],

  // Edge cases
  edgeCases: [
    '$0.99',
    '‚Ç¨1.000.000',
    '¬•100,000',
    'USD 0.01',
    '1,23 EUR',
    '1.23 USD',
    '1 234,56 EUR',
    '$1 000 000'
  ],

  // Invalid cases (should not match)
  invalid: [
    'abc123',
    '123abc',
    'USD',
    '$',
    '‚Ç¨',
    '123.456.789',
    'dollar',
    'euro'
  ]
};

/**
 * Test currency detection patterns
 */
export function testCurrencyDetection(detectFunction) {
  const results = {
    passed: 0,
    failed: 0,
    details: []
  };

  // Test all categories
  Object.keys(TEST_CASES).forEach(category => {
    if (category === 'invalid') {
      // Invalid cases should return null
      TEST_CASES[category].forEach(testCase => {
        const result = detectFunction(testCase);
        if (result === null) {
          results.passed++;
          results.details.push({
            testCase,
            category,
            status: 'PASS',
            result: null
          });
        } else {
          results.failed++;
          results.details.push({
            testCase,
            category,
            status: 'FAIL',
            result,
            expected: null
          });
        }
      });
    } else {
      // Valid cases should return currency info
      TEST_CASES[category].forEach(testCase => {
        const result = detectFunction(testCase);
        if (result && result.amount && result.currency) {
          results.passed++;
          results.details.push({ testCase, category, status: 'PASS', result });
        } else {
          results.failed++;
          results.details.push({
            testCase,
            category,
            status: 'FAIL',
            result,
            expected: 'currency object'
          });
        }
      });
    }
  });

  return results;
}
